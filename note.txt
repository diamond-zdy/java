包里面的程序 package 路径 （package com.bit）
\ 编译       .运行
java.util.*   导入所有包
 继承：is a 的关系  extends
面试问题：继承到底继承了父类的什么东西？
   答：除构造函数外的所有


default：包访问权限
super()
super.func()
super.data
this()
this.func()
this.data
一旦一个类被一个final修饰了 就不能被继承
父类引用只能调用父类自己的方法或访问自己的属性

向上转型所发生的时机：1.直接赋值 2.参数传递 3.方法返回值
向下转型的前提条件是：父类已经引用了子类（向下转型后的类型）的对象

注意： 向下转型要判断 instanceof

重写/覆盖/复写：1.函数名相同       子类的访问修饰限定符一定要大于等于父类的访问修饰限定符
     2.参数列表相同    父类的方法不能是私有的
     3.返回值也要相同
     4.静态的方法和private不能被重写
重载（Overload）：1.函数名相同
    2.参数列表不同（个数、类型）
    3.返回值不做要求
运行时绑定：动多态
1.先要上转型--->父类的引用 引用子类的对象
2.父类和子类 都有同名的覆盖方法（覆盖方法就叫做重写 也叫运行时绑定）
invokespecial:底层调用构造方法
invokevirtual:虚方法  除静态方法和构造方法 其他都是虚方法
invokestatic:静态方法
@Override:注解 //Ctrl + O

选学：动态绑定的原理                                                                                                                                                  
Class对象放在方法区
方法表在编译时产生 运行时地址进行覆盖

1.包含抽象方法的类叫抽象类
2.抽象类和普通类最大的区别包含抽象方法
3.抽象类不能被实例化 不能new
4.抽象类存在的意义-》肯定要被继承
5.抽象类一旦被继承就要重写抽象方法
6.如果一个类继承了抽象类 那么如果不想重写抽象类的方法 那么当前类需要设置为抽象类-》可以选择重写 也可以不重写
7.抽象类提前检查代码错误


面试问题：1.什么是多态
2.重载和重写的区别
3.super 和 this的区别
4.抽象类和接口的区别
5.访问修饰限定符了解吗？

应用：多态、抽象类、接口





